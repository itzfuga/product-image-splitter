<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Image Splitter & Auto-Crop v10 - Sequential Stitching</title>
    <script src="./Product Image Splitter & Auto-Crop v7_files/tesseract.min.js.Download"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
        }

        .header h1 {
            font-size: 32px;
            margin: 0 0 10px 0;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header p {
            color: #888;
            font-size: 16px;
        }

        .info-box {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .info-box h3 {
            color: #4ecdc4;
            margin: 0 0 10px 0;
        }

        .info-box p {
            color: #ccc;
            margin: 5px 0;
        }

        .upload-area {
            background: #2a2a2a;
            border: 3px dashed #444;
            border-radius: 20px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 40px;
            position: relative;
        }

        .upload-area:hover {
            border-color: #4ecdc4;
            background: #333;
        }

        .upload-area.dragover {
            border-color: #ff6b6b;
            background: #3a2a2a;
            transform: scale(1.02);
        }

        .upload-area.loading {
            border-color: #ffd93d;
            background: #3a3a2a;
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-text {
            font-size: 20px;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #888;
            font-size: 14px;
        }

        input[type="file"] {
            display: none;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #444;
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .settings-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }

        .settings-section.active {
            display: block;
        }

        .setting-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 20px;
        }

        .setting-label {
            flex: 1;
            color: #ccc;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        select {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            min-width: 250px;
        }

        .preview-section {
            display: none;
            margin-top: 40px;
        }

        .preview-section.active {
            display: block;
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .image-item {
            background: #2a2a2a;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s;
            position: relative;
        }

        .image-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .image-item img {
            width: 100%;
            height: 250px;
            object-fit: cover;
        }

        .image-info {
            padding: 15px;
            background: #333;
        }

        .image-name {
            font-size: 14px;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-status {
            font-size: 12px;
            color: #888;
        }

        .process-button {
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s;
            font-weight: bold;
        }

        .process-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.3);
        }

        .process-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .results-section {
            display: none;
            margin-top: 40px;
        }

        .results-section.active {
            display: block;
        }

        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .product-item {
            background: #2a2a2a;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s;
        }

        .product-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .product-image {
            width: 100%;
            height: 400px;
            object-fit: contain;
            background: white;
        }

        .product-info {
            padding: 20px;
            background: #333;
        }

        .product-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .product-details {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
        }

        .download-btn {
            background: #4ecdc4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            width: 100%;
        }

        .download-btn:hover {
            background: #45b7aa;
            transform: translateY(-1px);
        }

        .log-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
            max-height: 300px;
            overflow-y: auto;
        }

        .log-section h3 {
            color: #4ecdc4;
            margin: 0 0 15px 0;
        }

        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 5px;
        }

        .log-info {
            color: #ccc;
            background: #333;
        }

        .log-success {
            color: #4ecdc4;
            background: #2a3a3a;
        }

        .log-warning {
            color: #ffd93d;
            background: #3a3a2a;
        }

        .log-error {
            color: #ff6b6b;
            background: #3a2a2a;
        }

        .download-all-btn {
            background: linear-gradient(135deg, #ff6b6b, #ff9a9e);
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
        }

        .download-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(255, 107, 107, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Product Image Splitter & Auto-Crop v10</h1>
            <p>Sequential Stitching - Kombiniert Segmente √ºber Separator-Grenzen hinweg</p>
        </div>

        <div class="info-box">
            <h3>üìå How it works:</h3>
            <p>‚Ä¢ Upload your images in order (Taobao upload order is preserved)</p>
            <p>‚Ä¢ Tool automatically detects "START EXCEED END" separators</p>
            <p>‚Ä¢ Creates complete products by stitching bottom of image N with top of image N+1</p>
            <p>‚Ä¢ Headers and separator text are automatically removed</p>
        </div>

        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" multiple accept="image/*">
            <div class="upload-icon">üì∏</div>
            <div class="upload-text">Bilder hochladen oder hierher ziehen</div>
            <div class="upload-hint">Upload-Reihenfolge wird beibehalten (wichtig f√ºr Taobao!)</div>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <div>Lade Bilder...</div>
                </div>
            </div>
        </div>

        <div class="settings-section" id="settingsSection">
            <h3>‚öôÔ∏è Settings</h3>
            <div class="setting-row">
                <span class="setting-label">Detection Method</span>
                <select id="detectionMethod">
                    <option value="visual">Visual Detection (Fast, Recommended)</option>
                    <option value="ocr">OCR Text Recognition (Slower, More Accurate)</option>
                </select>
            </div>
        </div>

        <div class="preview-section" id="previewSection">
            <h3>üìã Uploaded Images</h3>
            <div class="images-grid" id="imagesGrid"></div>
            <button class="process-button" id="processButton">üöÄ Process Images</button>
        </div>

        <div class="results-section" id="resultsSection">
            <h3>‚ú® Processed Products</h3>
            <div class="product-grid" id="productGrid"></div>
            <button class="download-all-btn" id="downloadAllBtn">üì¶ Download All Products</button>
        </div>

        <div class="log-section">
            <h3>üìù Processing Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        // Global variables
        let uploadedImages = [];
        let processedProducts = [];
        let worker = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            initializeTesseract();
        });

        function initializeEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            // Drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            // Process button
            document.getElementById('processButton').addEventListener('click', processImages);

            // Download all button
            document.getElementById('downloadAllBtn').addEventListener('click', downloadAllProducts);
        }

        function initializeTesseract() {
            if (typeof Tesseract !== 'undefined') {
                addLog('Tesseract.js geladen', 'success');
            } else {
                addLog('Tesseract.js konnte nicht geladen werden (OCR nicht verf√ºgbar)', 'warning');
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');

            const files = Array.from(e.dataTransfer.files);
            processFiles(files);
        }

        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            processFiles(files);
        }

        async function processFiles(files) {
            const validFiles = files.filter(file => file.type.startsWith('image/'));

            if (validFiles.length === 0) {
                addLog('Keine g√ºltigen Bilddateien gefunden', 'warning');
                return;
            }

            for (let file of validFiles) {
                await loadImage(file);
            }

            displayImages();

            document.getElementById('settingsSection').classList.add('active');
            document.getElementById('previewSection').classList.add('active');
        }

        async function loadImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();

                reader.onload = function(e) {
                    const img = new Image();

                    img.onload = function() {
                        uploadedImages.push({
                            file: file,
                            img: img,
                            src: e.target.result,
                            width: img.width,
                            height: img.height,
                            index: uploadedImages.length
                        });

                        addLog(`Bild geladen: ${file.name} (${img.width}x${img.height})`, 'success');
                        resolve();
                    };

                    img.src = e.target.result;
                };

                reader.readAsDataURL(file);
            });
        }

        function displayImages() {
            const grid = document.getElementById('imagesGrid');
            grid.innerHTML = '';

            uploadedImages.forEach((image, index) => {
                const item = createImageItem(image, index);
                grid.appendChild(item);
            });
        }

        function createImageItem(image, index) {
            const item = document.createElement('div');
            item.className = 'image-item';

            item.innerHTML = `
                <img src="${image.src}" alt="${image.file.name}">
                <div class="image-info">
                    <div class="image-name">${image.file.name}</div>
                    <div class="image-status">${image.width}x${image.height}</div>
                </div>
            `;

            return item;
        }

        async function processImages() {
            const processButton = document.getElementById('processButton');
            processButton.disabled = true;
            processButton.textContent = '‚è≥ Processing...';

            addLog('=== Starte Sequential Stitching ===', 'info');

            processedProducts = [];

            // Step 1: Detect separators in each image and split into segments
            addLog('Schritt 1: Erkenne Separatoren in jedem Bild...', 'info');
            const allSegments = [];

            for (let i = 0; i < uploadedImages.length; i++) {
                const image = uploadedImages[i];
                addLog(`Analysiere Bild ${i + 1}/${uploadedImages.length}: ${image.file.name}`, 'info');

                const segments = await detectAndSplitImage(image, i);
                allSegments.push(...segments);
            }

            addLog(`Gefunden: ${allSegments.length} Segmente insgesamt`, 'success');

            // Step 2: Combine sequential segments into products
            addLog('Schritt 2: Kombiniere sequentielle Segmente zu Produkten...', 'info');
            let productIndex = 1;

            for (let i = 0; i < allSegments.length - 1; i++) {
                const currentSegment = allSegments[i];
                const nextSegment = allSegments[i + 1];

                // Skip if current segment is marked as separator or header
                if (currentSegment.type === 'separator' || currentSegment.type === 'header') {
                    continue;
                }

                // Create product from bottom of current + top of next
                await createProductFromSegments(currentSegment, nextSegment, productIndex);
                productIndex++;
            }

            displayResults();

            processButton.disabled = false;
            processButton.textContent = 'üöÄ Process Images';
        }

        async function detectAndSplitImage(image, imageIndex) {
            const detectionMethod = document.getElementById('detectionMethod').value;
            const removeHeaders = true; // Always remove headers

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image.img, 0, 0);

            let separatorPositions = [];

            if (detectionMethod === 'ocr') {
                separatorPositions = await detectSeparatorsOCR(image);
            } else {
                separatorPositions = await detectSeparatorsVisual(canvas, ctx);
            }

            addLog(`  ‚Üí ${separatorPositions.length} Separator(s) gefunden`, separatorPositions.length > 0 ? 'success' : 'info');

            // Split image into segments based on separator positions
            const segments = [];
            let lastY = 0;

            // Check for header in first 15% of image
            let firstContentY = 0;
            if (removeHeaders && imageIndex === 0) {
                const headerEnd = detectHeaderEnd(canvas, ctx);
                if (headerEnd > 0) {
                    addLog(`  ‚Üí Header erkannt bis Y=${headerEnd}`, 'info');
                    segments.push({
                        imageIndex,
                        type: 'header',
                        startY: 0,
                        endY: headerEnd,
                        image: image
                    });
                    firstContentY = headerEnd;
                    lastY = headerEnd;
                }
            }

            // Add segments between separators
            for (let i = 0; i < separatorPositions.length; i++) {
                const sepPos = separatorPositions[i];

                // Add content segment before separator
                if (sepPos.startY > lastY + 10) {
                    segments.push({
                        imageIndex,
                        type: 'content',
                        startY: lastY,
                        endY: sepPos.startY,
                        image: image,
                        position: i === 0 ? 'top' : 'middle'
                    });
                }

                // Add separator segment
                segments.push({
                    imageIndex,
                    type: 'separator',
                    startY: sepPos.startY,
                    endY: sepPos.endY,
                    image: image
                });

                lastY = sepPos.endY;
            }

            // Add final segment after last separator
            if (lastY < canvas.height - 10) {
                segments.push({
                    imageIndex,
                    type: 'content',
                    startY: lastY,
                    endY: canvas.height,
                    image: image,
                    position: separatorPositions.length > 0 ? 'bottom' : 'full'
                });
            }

            // If no separators found, treat whole image as one segment
            if (segments.filter(s => s.type === 'content').length === 0) {
                segments.push({
                    imageIndex,
                    type: 'content',
                    startY: firstContentY,
                    endY: canvas.height,
                    image: image,
                    position: 'full'
                });
            }

            return segments;
        }

        function detectHeaderEnd(canvas, ctx) {
            // Look for horizontal lines or text in top 15%
            const scanHeight = Math.floor(canvas.height * 0.15);
            const imageData = ctx.getImageData(0, 0, canvas.width, scanHeight);
            const data = imageData.data;

            // Scan horizontally for lines
            for (let y = 0; y < scanHeight; y++) {
                let darkPixels = 0;
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    if (brightness < 100) darkPixels++;
                }

                // If we find a horizontal line (>50% dark pixels)
                if (darkPixels / canvas.width > 0.5) {
                    // Return position 10 pixels below the line
                    return Math.min(y + 10, scanHeight);
                }
            }

            return 0;
        }

        async function detectSeparatorsVisual(canvas, ctx) {
            const separators = [];
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // Scan for horizontal bands with "START EXCEED END" text characteristics
            // Look for white text on gray/white background
            const rowHeight = 5; // Sample every 5 pixels

            for (let y = 0; y < canvas.height - 100; y += rowHeight) {
                // Check a horizontal band
                let whitePixels = 0;
                let grayPixels = 0;
                const bandHeight = 80; // Height of separator band

                for (let by = y; by < Math.min(y + bandHeight, canvas.height); by++) {
                    for (let x = Math.floor(canvas.width * 0.2); x < Math.floor(canvas.width * 0.8); x++) {
                        const idx = (by * canvas.width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const brightness = (r + g + b) / 3;

                        if (brightness > 240) whitePixels++;
                        else if (brightness > 180 && brightness < 240) grayPixels++;
                    }
                }

                const totalPixels = bandHeight * (canvas.width * 0.6);
                const whitePct = whitePixels / totalPixels;

                // If mostly white/light gray (typical separator area)
                if (whitePct > 0.8) {
                    // Check if we already have a separator nearby
                    const hasNearbySeparator = separators.some(sep =>
                        Math.abs(sep.startY - y) < 100
                    );

                    if (!hasNearbySeparator) {
                        separators.push({
                            startY: y,
                            endY: Math.min(y + bandHeight, canvas.height)
                        });
                        y += bandHeight; // Skip ahead
                    }
                }
            }

            return separators;
        }

        async function detectSeparatorsOCR(image) {
            if (!worker) {
                try {
                    worker = await Tesseract.createWorker();
                    await worker.loadLanguage('eng');
                    await worker.initialize('eng');
                } catch (error) {
                    addLog('OCR-Initialisierung fehlgeschlagen, verwende visuelle Erkennung', 'warning');
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    ctx.drawImage(image.img, 0, 0);
                    return await detectSeparatorsVisual(canvas, ctx);
                }
            }

            try {
                const result = await worker.recognize(image.src);
                const words = result.data.words;

                const separators = [];

                // Look for "START", "EXCEED", "END" words
                for (let word of words) {
                    const text = word.text.toUpperCase();
                    if (text.includes('START') || text.includes('EXCEED') || text.includes('END')) {
                        // Found separator text, mark region
                        const y = word.bbox.y0;
                        const height = word.bbox.y1 - word.bbox.y0;

                        // Expand to include full separator area
                        separators.push({
                            startY: Math.max(0, y - 20),
                            endY: Math.min(image.height, y + height + 20)
                        });
                    }
                }

                // Merge overlapping separators
                return mergeSeparators(separators);

            } catch (error) {
                addLog(`OCR-Fehler: ${error.message}, verwende visuelle Erkennung`, 'warning');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = image.width;
                canvas.height = image.height;
                ctx.drawImage(image.img, 0, 0);
                return await detectSeparatorsVisual(canvas, ctx);
            }
        }

        function mergeSeparators(separators) {
            if (separators.length === 0) return [];

            // Sort by startY
            separators.sort((a, b) => a.startY - b.startY);

            const merged = [separators[0]];

            for (let i = 1; i < separators.length; i++) {
                const current = separators[i];
                const last = merged[merged.length - 1];

                // If overlapping or close (within 50px), merge
                if (current.startY <= last.endY + 50) {
                    last.endY = Math.max(last.endY, current.endY);
                } else {
                    merged.push(current);
                }
            }

            return merged;
        }

        async function createProductFromSegments(bottomSegment, topSegment, productIndex) {
            addLog(`Erstelle Produkt ${productIndex}...`, 'info');

            // Create canvas with combined segments
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Calculate heights
            const bottomHeight = bottomSegment.endY - bottomSegment.startY;
            const topHeight = topSegment.endY - topSegment.startY;
            const totalHeight = bottomHeight + topHeight;
            const width = Math.max(bottomSegment.image.width, topSegment.image.width);

            canvas.width = width;
            canvas.height = totalHeight;

            // Fill white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw bottom segment
            ctx.drawImage(
                bottomSegment.image.img,
                0, bottomSegment.startY,
                bottomSegment.image.width, bottomHeight,
                0, 0,
                bottomSegment.image.width, bottomHeight
            );

            // Draw top segment
            ctx.drawImage(
                topSegment.image.img,
                0, topSegment.startY,
                topSegment.image.width, topHeight,
                0, bottomHeight,
                topSegment.image.width, topHeight
            );

            // Crop to content
            const croppedCanvas = autoCropCanvas(canvas);

            // Save product
            processedProducts.push({
                index: productIndex,
                canvas: croppedCanvas,
                dataUrl: croppedCanvas.toDataURL('image/jpeg', 0.95),
                filename: `product_${productIndex}.jpg`,
                dimensions: `${croppedCanvas.width}x${croppedCanvas.height}`,
                segments: [bottomSegment.imageIndex, topSegment.imageIndex]
            });

            addLog(`‚úì Produkt ${productIndex} erstellt (${croppedCanvas.width}x${croppedCanvas.height})`, 'success');
        }

        function autoCropCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            let minX = canvas.width;
            let minY = canvas.height;
            let maxX = 0;
            let maxY = 0;

            // Detect content bounds
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const brightness = (r + g + b) / 3;

                    // If not white/near-white
                    if (brightness < 250) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // Add small padding
            const padding = 10;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(canvas.width, maxX + padding);
            maxY = Math.min(canvas.height, maxY + padding);

            const cropWidth = maxX - minX;
            const cropHeight = maxY - minY;

            // Create cropped canvas
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCanvas.width = cropWidth;
            croppedCanvas.height = cropHeight;

            croppedCtx.fillStyle = 'white';
            croppedCtx.fillRect(0, 0, cropWidth, cropHeight);
            croppedCtx.drawImage(canvas, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            return croppedCanvas;
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            const productGrid = document.getElementById('productGrid');

            resultsSection.classList.add('active');
            productGrid.innerHTML = '';

            processedProducts.forEach(product => {
                const item = document.createElement('div');
                item.className = 'product-item';

                item.innerHTML = `
                    <img src="${product.dataUrl}" class="product-image" alt="Product ${product.index}">
                    <div class="product-info">
                        <div class="product-title">Produkt ${product.index}</div>
                        <div class="product-details">
                            Gr√∂√üe: ${product.dimensions}<br>
                            Aus Bildern: ${product.segments.map(i => i + 1).join(', ')}
                        </div>
                        <button class="download-btn" onclick="downloadProduct(${product.index - 1})">
                            üíæ Download
                        </button>
                    </div>
                `;

                productGrid.appendChild(item);
            });

            addLog(`=== ‚ú® Fertig! ${processedProducts.length} Produkte erstellt ===`, 'success');
        }

        function downloadProduct(index) {
            const product = processedProducts[index];
            const link = document.createElement('a');
            link.download = product.filename;
            link.href = product.dataUrl;
            link.click();

            addLog(`Download: ${product.filename}`, 'info');
        }

        function downloadAllProducts() {
            processedProducts.forEach((product, index) => {
                setTimeout(() => {
                    downloadProduct(index);
                }, index * 200);
            });

            addLog(`Alle ${processedProducts.length} Produkte werden heruntergeladen...`, 'info');
        }

        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', async () => {
            if (worker) {
                await worker.terminate();
            }
        });
    </script>
</body>
</html>

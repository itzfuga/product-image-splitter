<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Image Splitter & Auto-Crop v9 - Optimized 4:5 Ratio</title>
    <script src="./Product Image Splitter & Auto-Crop v7_files/tesseract.min.js.Download"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #fff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        
        .header h1 {
            font-size: 32px;
            margin: 0 0 10px 0;
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .header p {
            color: #888;
            font-size: 16px;
        }
        
        .info-box {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .info-box h3 {
            color: #4ecdc4;
            margin: 0 0 10px 0;
        }
        
        .info-box p {
            color: #ccc;
            margin: 5px 0;
        }
        
        .upload-area {
            background: #2a2a2a;
            border: 3px dashed #444;
            border-radius: 20px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 40px;
            position: relative;
        }
        
        .upload-area:hover {
            border-color: #4ecdc4;
            background: #333;
        }
        
        .upload-area.dragover {
            border-color: #ff6b6b;
            background: #3a2a2a;
            transform: scale(1.02);
        }
        
        .upload-area.loading {
            border-color: #ffd93d;
            background: #3a3a2a;
        }
        
        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }
        
        .upload-text {
            font-size: 20px;
            margin-bottom: 10px;
        }
        
        .upload-hint {
            color: #888;
            font-size: 14px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            border-radius: 20px;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .loading-content {
            text-align: center;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #444;
            border-top-color: #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .settings-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            display: none;
        }
        
        .settings-section.active {
            display: block;
        }
        
        .setting-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 20px;
        }
        
        .setting-label {
            flex: 1;
            color: #ccc;
        }
        
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        input[type="number"] {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            width: 100px;
        }
        
        select {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            min-width: 250px;
        }
        
        .preview-section {
            display: none;
            margin-top: 40px;
        }
        
        .preview-section.active {
            display: block;
        }
        
        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .image-item {
            background: #2a2a2a;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s;
            position: relative;
            cursor: grab;
        }
        
        .image-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .image-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .image-item img {
            width: 100%;
            height: 250px;
            object-fit: cover;
        }
        
        .image-info {
            padding: 15px;
            background: #333;
        }
        
        .image-name {
            font-size: 14px;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .image-status {
            font-size: 12px;
            color: #888;
        }
        
        .separator-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff6b6b;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .manual-separator-btn {
            position: absolute;
            bottom: 60px;
            right: 10px;
            background: #4ecdc4;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .image-item:hover .manual-separator-btn {
            opacity: 1;
        }
        
        .process-button {
            background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            padding: 15px 50px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        .process-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.3);
        }
        
        .process-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .results-section {
            display: none;
            margin-top: 40px;
        }
        
        .results-section.active {
            display: block;
        }
        
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .product-item {
            background: #2a2a2a;
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s;
        }
        
        .product-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .product-image {
            width: 100%;
            height: 400px;
            object-fit: cover;
            background: #333;
        }
        
        .product-info {
            padding: 20px;
            background: #333;
        }
        
        .product-title {
            font-size: 18px;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        
        .product-details {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
        }
        
        .download-btn {
            background: #4ecdc4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            width: 100%;
        }
        
        .download-btn:hover {
            background: #45b7aa;
            transform: translateY(-1px);
        }
        
        .log-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-section h3 {
            color: #4ecdc4;
            margin: 0 0 15px 0;
        }
        
        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .log-info {
            color: #ccc;
            background: #333;
        }
        
        .log-success {
            color: #4ecdc4;
            background: #2a3a3a;
        }
        
        .log-warning {
            color: #ffd93d;
            background: #3a3a2a;
        }
        
        .log-error {
            color: #ff6b6b;
            background: #3a2a2a;
        }
        
        .group-mode-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            background: #333;
            padding: 15px;
            border-radius: 10px;
        }
        
        .group-mode-option {
            flex: 1;
            padding: 15px;
            border: 2px solid #444;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .group-mode-option:hover {
            border-color: #4ecdc4;
            background: #3a3a3a;
        }
        
        .group-mode-option.active {
            border-color: #4ecdc4;
            background: #2a4a4a;
        }
        
        .group-mode-option h4 {
            margin: 0 0 5px 0;
            color: #4ecdc4;
        }
        
        .group-mode-option p {
            margin: 0;
            font-size: 12px;
            color: #888;
        }
        
        .manual-groups {
            display: none;
            background: #333;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .manual-groups.active {
            display: block;
        }
        
        .group-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .group-box {
            flex: 1;
            min-width: 200px;
            background: #2a2a2a;
            border: 2px dashed #555;
            border-radius: 10px;
            padding: 20px;
            min-height: 150px;
            transition: all 0.3s;
        }
        
        .group-box.drag-over {
            border-color: #4ecdc4;
            background: #2a3a3a;
        }
        
        .group-box h4 {
            margin: 0 0 10px 0;
            color: #4ecdc4;
        }
        
        .group-images {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .group-image {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 5px;
            cursor: grab;
        }
        
        .download-all-btn {
            background: linear-gradient(135deg, #ff6b6b, #ff9a9e);
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 20px;
            border-radius: 50px;
            cursor: pointer;
            margin: 30px auto;
            display: block;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
        }
        
        .download-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 30px rgba(255, 107, 107, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Product Image Splitter & Auto-Crop v9</h1>
            <p>Optimiert f√ºr 4:5 Aspect Ratio mit verbesserter Erkennung</p>
        </div>
        
        <div class="info-box">
            <h3>üìå NEU in Version 9:</h3>
            <p>‚Ä¢ <strong>4:5 Aspect Ratio:</strong> Alle Bilder werden automatisch im 4:5 Format erstellt</p>
            <p>‚Ä¢ <strong>Verbesserte Erkennung:</strong> Intelligentere Content-Erkennung ohne Abschneiden</p>
            <p>‚Ä¢ <strong>Optimiertes Cropping:</strong> Kein unerw√ºnschter Whitespace mehr</p>
            <p>‚Ä¢ <strong>Konsistente Ergebnisse:</strong> Einheitliche Bildgr√∂√üen f√ºr alle Produkte</p>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" multiple accept="image/*">
            <div class="upload-icon">üì∏</div>
            <div class="upload-text">Bilder hochladen oder hierher ziehen</div>
            <div class="upload-hint">Auch URLs (z.B. von Taobao) k√∂nnen eingef√ºgt werden</div>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="loading-content">
                    <div class="loading-spinner"></div>
                    <div>Lade Bilder...</div>
                </div>
            </div>
        </div>
        
        <div class="settings-section" id="settingsSection">
            <h3>‚öôÔ∏è Einstellungen</h3>
            <div class="setting-row">
                <span class="setting-label">Sortierung der Bilder</span>
                <select id="sortOrder" onchange="changeSortOrder()">
                    <option value="upload">Upload-Reihenfolge (empfohlen f√ºr Taobao)</option>
                    <option value="filename">Dateiname (A-Z)</option>
                    <option value="manual">Manuell (Drag & Drop)</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">4:5 Aspect Ratio erzwingen</span>
                <div class="checkbox-wrapper">
                    <input type="checkbox" id="force45Ratio" checked>
                    <label for="force45Ratio">Aktiviert (empfohlen)</label>
                </div>
            </div>
            <div class="setting-row">
                <span class="setting-label">Padding um Inhalt (Pixel)</span>
                <input type="number" id="contentPadding" value="20" min="0" max="100">
            </div>
            <div class="setting-row">
                <span class="setting-label">Hintergrundfarbe</span>
                <select id="backgroundColor">
                    <option value="white">Wei√ü</option>
                    <option value="#f5f5f5">Hellgrau</option>
                    <option value="#e0e0e0">Grau</option>
                </select>
            </div>
        </div>
        
        <div class="preview-section" id="previewSection">
            <h3>üìã Hochgeladene Bilder</h3>
            
            <div class="group-mode-selector">
                <div class="group-mode-option active" data-mode="auto">
                    <h4>ü§ñ Automatisch</h4>
                    <p>Nutzt visueller Analyse und Mustererkennung</p>
                </div>
                <div class="group-mode-option" data-mode="ocr">
                    <h4>üîç OCR-Erkennung</h4>
                    <p>Sucht nach "STAFF/START EXCEED END" Text</p>
                </div>
                <div class="group-mode-option" data-mode="manual">
                    <h4>‚úã Manuell</h4>
                    <p>Gruppiere Bilder per Drag & Drop</p>
                </div>
            </div>
            
            <div class="images-grid" id="imagesGrid"></div>
            
            <div class="manual-groups" id="manualGroups">
                <h4>Ziehe Bilder in die Gruppen:</h4>
                <div class="group-container" id="groupContainer"></div>
            </div>
            
            <button class="process-button" id="processButton">üöÄ Bilder verarbeiten</button>
        </div>
        
        <div class="results-section" id="resultsSection">
            <h3>‚ú® Verarbeitete Produkte</h3>
            <div class="product-grid" id="productGrid"></div>
            <button class="download-all-btn" id="downloadAllBtn">üì¶ Alle Produkte herunterladen</button>
        </div>
        
        <div class="log-section">
            <h3>üìù Verarbeitungsprotokoll</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        // Global variables
        let uploadedImages = [];
        let processedProducts = [];
        let groupingMode = 'auto';
        let manualGroups = [];
        let worker = null;
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeEventListeners();
            initializeTesseract();
        });
        
        function initializeEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            
            // Paste event for URLs
            document.addEventListener('paste', handlePaste);
            
            // Process button
            document.getElementById('processButton').addEventListener('click', processImages);
            
            // Download all button
            document.getElementById('downloadAllBtn').addEventListener('click', downloadAllProducts);
            
            // Grouping mode selector
            document.querySelectorAll('.group-mode-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.group-mode-option').forEach(opt => opt.classList.remove('active'));
                    this.classList.add('active');
                    groupingMode = this.dataset.mode;
                    
                    if (groupingMode === 'manual') {
                        document.getElementById('manualGroups').classList.add('active');
                        initializeManualGroups();
                    } else {
                        document.getElementById('manualGroups').classList.remove('active');
                    }
                });
            });
        }
        
        function initializeTesseract() {
            if (typeof Tesseract !== 'undefined') {
                addLog('Tesseract.js geladen', 'success');
            } else {
                addLog('Tesseract.js konnte nicht geladen werden', 'error');
            }
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            processFiles(files);
        }
        
        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            processFiles(files);
        }
        
        async function handlePaste(e) {
            const items = Array.from(e.clipboardData.items);
            
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    processFiles([blob]);
                } else if (item.type === 'text/plain') {
                    item.getAsString(async (text) => {
                        if (isValidUrl(text)) {
                            await loadImageFromUrl(text);
                        }
                    });
                }
            }
        }
        
        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }
        
        async function loadImageFromUrl(url) {
            const uploadArea = document.getElementById('uploadArea');
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            uploadArea.classList.add('loading');
            loadingOverlay.classList.add('active');
            
            addLog(`Lade Bild von URL: ${url}`, 'info');
            
            try {
                // Try direct loading first
                let imgUrl = url;
                
                // For Taobao images, ensure HTTPS
                if (url.includes('taobao.com') || url.includes('alicdn.com')) {
                    imgUrl = url.replace('http://', 'https://');
                }
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => {
                        // Try with proxy
                        addLog('Direktes Laden fehlgeschlagen, verwende Proxy...', 'warning');
                        img.src = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
                        img.onload = resolve;
                        img.onerror = reject;
                    };
                    img.src = imgUrl;
                });
                
                // Create a file-like object
                const response = await fetch(img.src);
                const blob = await response.blob();
                const fileName = `image_${Date.now()}_${url.split('/').pop().split('?')[0]}`;
                const file = new File([blob], fileName, { type: blob.type });
                
                processFiles([file]);
                
            } catch (error) {
                addLog(`Fehler beim Laden der URL: ${error.message}`, 'error');
            } finally {
                uploadArea.classList.remove('loading');
                loadingOverlay.classList.remove('active');
            }
        }
        
        async function processFiles(files) {
            const validFiles = files.filter(file => file.type.startsWith('image/'));
            
            if (validFiles.length === 0) {
                addLog('Keine g√ºltigen Bilddateien gefunden', 'warning');
                return;
            }
            
            for (let file of validFiles) {
                await loadImage(file);
            }
            
            sortImages();
            displayImages();
            
            document.getElementById('settingsSection').classList.add('active');
            document.getElementById('previewSection').classList.add('active');
        }
        
        async function loadImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    
                    img.onload = function() {
                        uploadedImages.push({
                            file: file,
                            img: img,
                            src: e.target.result,
                            width: img.width,
                            height: img.height,
                            index: uploadedImages.length,
                            isSeparator: false,
                            ocrChecked: false
                        });
                        
                        addLog(`Bild geladen: ${file.name} (${img.width}x${img.height})`, 'success');
                        resolve();
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        function sortImages() {
            const sortOrder = document.getElementById('sortOrder').value;
            
            switch (sortOrder) {
                case 'filename':
                    uploadedImages.sort((a, b) => a.file.name.localeCompare(b.file.name));
                    break;
                case 'upload':
                default:
                    // Keep upload order
                    break;
            }
            
            // Update indices
            uploadedImages.forEach((img, index) => {
                img.index = index;
            });
        }
        
        function changeSortOrder() {
            sortImages();
            displayImages();
        }
        
        function displayImages() {
            const grid = document.getElementById('imagesGrid');
            grid.innerHTML = '';
            
            uploadedImages.forEach((image, index) => {
                const item = createImageItem(image, index);
                grid.appendChild(item);
            });
            
            if (document.getElementById('sortOrder').value === 'manual') {
                enableManualSorting();
            }
        }
        
        function createImageItem(image, index) {
            const item = document.createElement('div');
            item.className = 'image-item';
            item.dataset.index = index;
            
            if (image.isSeparator) {
                item.innerHTML = `
                    <div class="separator-badge">TRENNER</div>
                `;
            }
            
            item.innerHTML += `
                <img src="${image.src}" alt="${image.file.name}">
                <div class="image-info">
                    <div class="image-name">${image.file.name}</div>
                    <div class="image-status">${image.width}x${image.height}</div>
                </div>
                <button class="manual-separator-btn" onclick="toggleSeparator(${index})">
                    ${image.isSeparator ? 'Kein Trenner' : 'Als Trenner'}
                </button>
            `;
            
            return item;
        }
        
        function toggleSeparator(index) {
            uploadedImages[index].isSeparator = !uploadedImages[index].isSeparator;
            displayImages();
            addLog(`Bild ${index + 1} als ${uploadedImages[index].isSeparator ? 'Trenner' : 'Produkt'} markiert`, 'info');
        }
        
        function enableManualSorting() {
            const grid = document.getElementById('imagesGrid');
            new Sortable(grid, {
                animation: 150,
                onEnd: function(evt) {
                    const newOrder = [];
                    grid.querySelectorAll('.image-item').forEach(item => {
                        const index = parseInt(item.dataset.index);
                        newOrder.push(uploadedImages[index]);
                    });
                    uploadedImages = newOrder;
                    uploadedImages.forEach((img, index) => img.index = index);
                    displayImages();
                }
            });
        }
        
        function initializeManualGroups() {
            const container = document.getElementById('groupContainer');
            container.innerHTML = '';
            
            // Create 5 default groups
            for (let i = 1; i <= 5; i++) {
                const groupBox = document.createElement('div');
                groupBox.className = 'group-box';
                groupBox.dataset.group = i;
                groupBox.innerHTML = `
                    <h4>Produkt ${i}</h4>
                    <div class="group-images" id="group-${i}"></div>
                `;
                
                groupBox.addEventListener('dragover', handleGroupDragOver);
                groupBox.addEventListener('dragleave', handleGroupDragLeave);
                groupBox.addEventListener('drop', handleGroupDrop);
                
                container.appendChild(groupBox);
            }
            
            // Make images draggable
            document.querySelectorAll('.image-item img').forEach(img => {
                img.draggable = true;
                img.addEventListener('dragstart', handleImageDragStart);
            });
        }
        
        function handleImageDragStart(e) {
            const imageItem = e.target.closest('.image-item');
            e.dataTransfer.setData('imageIndex', imageItem.dataset.index);
        }
        
        function handleGroupDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }
        
        function handleGroupDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }
        
        function handleGroupDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            const imageIndex = parseInt(e.dataTransfer.getData('imageIndex'));
            const groupNum = parseInt(e.currentTarget.dataset.group);
            
            // Add image to group
            const groupImages = document.getElementById(`group-${groupNum}`);
            const img = document.createElement('img');
            img.className = 'group-image';
            img.src = uploadedImages[imageIndex].src;
            img.dataset.index = imageIndex;
            groupImages.appendChild(img);
            
            // Update manual groups
            if (!manualGroups[groupNum - 1]) {
                manualGroups[groupNum - 1] = [];
            }
            manualGroups[groupNum - 1].push(imageIndex);
        }
        
        async function processImages() {
            const processButton = document.getElementById('processButton');
            processButton.disabled = true;
            
            addLog('Starte Verarbeitung...', 'info');
            
            processedProducts = [];
            
            if (groupingMode === 'ocr') {
                await processWithOCR();
            } else if (groupingMode === 'manual') {
                await processManualGroups();
            } else {
                await processWithAutoGrouping();
            }
            
            displayResults();
            processButton.disabled = false;
        }
        
        async function processWithOCR() {
            addLog('OCR-Modus: Suche nach Trennbildern...', 'info');
            
            // Check each image for separator text
            for (let i = 0; i < uploadedImages.length; i++) {
                if (!uploadedImages[i].ocrChecked) {
                    const isSeparator = await checkForSeparatorText(uploadedImages[i]);
                    uploadedImages[i].isSeparator = isSeparator;
                    uploadedImages[i].ocrChecked = true;
                    
                    if (isSeparator) {
                        addLog(`Trennbild gefunden: ${uploadedImages[i].file.name}`, 'success');
                    }
                }
            }
            
            // Group images based on separators
            let productIndex = 1;
            let currentSegments = [];
            
            for (let i = 0; i < uploadedImages.length; i++) {
                const image = uploadedImages[i];
                
                if (image.isSeparator && currentSegments.length > 0) {
                    // Create product from current segments
                    await createProductImage(currentSegments, productIndex);
                    productIndex++;
                    currentSegments = [];
                } else if (!image.isSeparator) {
                    currentSegments.push({
                        image: image,
                        startY: 0,
                        endY: 1
                    });
                }
            }
            
            // Process remaining segments
            if (currentSegments.length > 0) {
                await createProductImage(currentSegments, productIndex);
            }
        }
        
        async function processManualGroups() {
            addLog('Manueller Modus: Verarbeite Gruppen...', 'info');
            
            for (let i = 0; i < manualGroups.length; i++) {
                if (manualGroups[i] && manualGroups[i].length > 0) {
                    const segments = manualGroups[i].map(imageIndex => ({
                        image: uploadedImages[imageIndex],
                        startY: 0,
                        endY: 1
                    }));
                    
                    await createProductImage(segments, i + 1);
                }
            }
        }
        
        async function processWithAutoGrouping() {
            addLog('Auto-Modus: Intelligente Gruppierung...', 'info');
            
            // Simple auto-grouping: look for patterns
            // This is a simplified version - you can enhance it with more sophisticated logic
            
            let groups = [];
            let currentGroup = [];
            
            for (let i = 0; i < uploadedImages.length; i++) {
                const image = uploadedImages[i];
                
                // Check if this might be a separator based on visual characteristics
                const mightBeSeparator = await checkVisualSeparator(image);
                
                if (mightBeSeparator && currentGroup.length > 0) {
                    groups.push(currentGroup);
                    currentGroup = [];
                } else if (!mightBeSeparator) {
                    currentGroup.push({
                        image: image,
                        startY: 0,
                        endY: 1
                    });
                }
            }
            
            // Add last group
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }
            
            // If no separators found, treat all as one product
            if (groups.length === 0) {
                groups = [uploadedImages.map(img => ({
                    image: img,
                    startY: 0,
                    endY: 1
                }))];
            }
            
            // Process each group
            for (let i = 0; i < groups.length; i++) {
                await createProductImage(groups[i], i + 1);
            }
        }
        
        async function checkForSeparatorText(image) {
            if (!worker) {
                worker = await Tesseract.createWorker();
                await worker.loadLanguage('eng+chi_sim');
                await worker.initialize('eng+chi_sim');
            }
            
            try {
                const result = await worker.recognize(image.src);
                const text = result.data.text.toUpperCase();
                
                // Check for separator keywords
                const separatorKeywords = ['STAFF', 'START', 'EXCEED', 'END', 'ÂëòÂ∑•', 'ÂºÄÂßã', 'Ë∂ÖËøá', 'ÁªìÊùü'];
                
                return separatorKeywords.some(keyword => text.includes(keyword));
            } catch (error) {
                addLog(`OCR-Fehler: ${error.message}`, 'error');
                return false;
            }
        }
        
        async function checkVisualSeparator(image) {
            // Create canvas to analyze image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image.img, 0, 0);
            
            // Get image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Analyze color distribution
            let grayPixels = 0;
            let totalPixels = canvas.width * canvas.height;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Check if pixel is gray
                const isGray = Math.abs(r - g) < 20 && Math.abs(g - b) < 20 && Math.abs(r - b) < 20;
                if (isGray && r > 100 && r < 200) {
                    grayPixels++;
                }
            }
            
            // If more than 70% gray pixels, might be separator
            return (grayPixels / totalPixels) > 0.7;
        }

        function detectContentBounds(canvas, ctx) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let minX = canvas.width;
            let minY = canvas.height;
            let maxX = 0;
            let maxY = 0;
            
            // More aggressive content detection
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];
                    
                    // Skip transparent pixels
                    if (a < 10) continue;
                    
                    // Calculate color difference from common backgrounds
                    const grayDiff = Math.abs(r - g) + Math.abs(g - b) + Math.abs(r - b);
                    const brightness = (r + g + b) / 3;
                    
                    // Check if pixel is likely content (not uniform background)
                    const isContent = grayDiff > 15 || // Not gray
                                    brightness < 240 || // Not too bright
                                    (brightness < 250 && grayDiff > 5); // Subtle content
                    
                    if (isContent) {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            // If no content found, use full canvas
            if (minX === canvas.width) {
                return { minX: 0, minY: 0, maxX: canvas.width, maxY: canvas.height };
            }
            
            return { minX, minY, maxX, maxY };
        }

        async function createProductImage(segments, productIndex) {
            if (segments.length === 0) return;
            
            addLog(`Erstelle Produkt ${productIndex} aus ${segments.length} Segmenten...`, 'info');
            
            const force45Ratio = document.getElementById('force45Ratio').checked;
            const contentPadding = parseInt(document.getElementById('contentPadding').value) || 20;
            const backgroundColor = document.getElementById('backgroundColor').value;
            
            // Calculate total height needed
            let totalHeight = 0;
            let maxWidth = 0;
            
            segments.forEach(segment => {
                const height = (segment.endY - segment.startY) * segment.image.img.height;
                totalHeight += height;
                maxWidth = Math.max(maxWidth, segment.image.img.width);
            });
            
            // Create initial canvas with all segments
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = maxWidth;
            tempCanvas.height = totalHeight;
            
            // Fill background
            tempCtx.fillStyle = backgroundColor;
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw all segments
            let currentY = 0;
            segments.forEach((segment, idx) => {
                const img = segment.image.img;
                const sourceY = segment.startY * img.height;
                const sourceHeight = (segment.endY - segment.startY) * img.height;
                
                tempCtx.drawImage(
                    img,
                    0, sourceY, img.width, sourceHeight,
                    0, currentY, img.width, sourceHeight
                );
                
                currentY += sourceHeight;
            });
            
            // Detect content bounds with less aggressive cropping
            const bounds = detectContentBounds(tempCanvas, tempCtx);
            
            // Calculate content dimensions
            let contentWidth = bounds.maxX - bounds.minX;
            let contentHeight = bounds.maxY - bounds.minY;
            
            // Ensure minimum dimensions
            contentWidth = Math.max(contentWidth, 100);
            contentHeight = Math.max(contentHeight, 100);
            
            let finalWidth, finalHeight;
            
            if (force45Ratio) {
                // Calculate dimensions for 4:5 ratio
                const targetRatio = 4 / 5; // width / height
                const currentRatio = contentWidth / contentHeight;
                
                if (currentRatio > targetRatio) {
                    // Content is wider than 4:5, fit by width
                    finalWidth = contentWidth + (contentPadding * 2);
                    finalHeight = finalWidth / targetRatio;
                } else {
                    // Content is taller than 4:5, fit by height
                    finalHeight = contentHeight + (contentPadding * 2);
                    finalWidth = finalHeight * targetRatio;
                }
            } else {
                // Use content dimensions with padding
                finalWidth = contentWidth + (contentPadding * 2);
                finalHeight = contentHeight + (contentPadding * 2);
            }
            
            // Create final canvas
            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            finalCanvas.width = Math.round(finalWidth);
            finalCanvas.height = Math.round(finalHeight);
            
            // Fill background
            finalCtx.fillStyle = backgroundColor;
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            
            // Calculate position to center content
            const offsetX = (finalCanvas.width - contentWidth) / 2;
            const offsetY = (finalCanvas.height - contentHeight) / 2;
            
            // Draw cropped content centered
            finalCtx.drawImage(
                tempCanvas,
                bounds.minX, bounds.minY, contentWidth, contentHeight,
                offsetX, offsetY, contentWidth, contentHeight
            );
            
            // Save product
            processedProducts.push({
                index: productIndex,
                canvas: finalCanvas,
                dataUrl: finalCanvas.toDataURL('image/png'),
                filename: `product_${productIndex}.png`,
                dimensions: `${finalCanvas.width}x${finalCanvas.height}`,
                ratio: force45Ratio ? '4:5' : `${Math.round(finalCanvas.width/finalCanvas.height * 100)/100}:1`
            });
            
            addLog(`‚úì Produkt ${productIndex} erstellt! (${finalCanvas.width}x${finalCanvas.height}, Ratio: ${force45Ratio ? '4:5' : 'Original'})`, 'success');
        }

        function displayResults() {
            const resultsSection = document.getElementById('resultsSection');
            const productGrid = document.getElementById('productGrid');
            
            resultsSection.classList.add('active');
            productGrid.innerHTML = '';
            
            processedProducts.forEach(product => {
                const item = document.createElement('div');
                item.className = 'product-item';
                
                item.innerHTML = `
                    <img src="${product.dataUrl}" class="product-image" alt="Product ${product.index}">
                    <div class="product-info">
                        <div class="product-title">Produkt ${product.index}</div>
                        <div class="product-details">
                            Gr√∂√üe: ${product.dimensions}<br>
                            Ratio: ${product.ratio}
                        </div>
                        <button class="download-btn" onclick="downloadProduct(${product.index - 1})">
                            üíæ Download
                        </button>
                    </div>
                `;
                
                productGrid.appendChild(item);
            });
            
            addLog(`‚ú® Verarbeitung abgeschlossen! ${processedProducts.length} Produkte erstellt.`, 'success');
        }
        
        function downloadProduct(index) {
            const product = processedProducts[index];
            const link = document.createElement('a');
            link.download = product.filename;
            link.href = product.dataUrl;
            link.click();
            
            addLog(`Download: ${product.filename}`, 'info');
        }
        
        function downloadAllProducts() {
            processedProducts.forEach((product, index) => {
                setTimeout(() => {
                    downloadProduct(index);
                }, index * 200); // Delay to prevent browser blocking
            });
            
            addLog(`Alle ${processedProducts.length} Produkte werden heruntergeladen...`, 'info');
        }
        
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Clean up on page unload
        window.addEventListener('beforeunload', async () => {
            if (worker) {
                await worker.terminate();
            }
        });
    </script>
    
    <!-- Add Sortable.js for drag and drop sorting -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
</body>
</html>